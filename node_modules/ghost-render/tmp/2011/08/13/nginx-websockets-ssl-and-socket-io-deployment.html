<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

	<title>Nginx, Websockets, SSL and Socket.IO deployment</title>	

	<meta name="description" content="">
	
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Nginx, Websockets, SSL and Socket.IO deployment">
    <meta name="twitter:description" content="">
    <meta name="twitter:site" content="@username">
	<meta name="twitter:creator" content="@username">

    <meta property="og:type" content="article">
    <meta property="og:title" content="Nginx, Websockets, SSL and Socket.IO deployment">
    <meta property="og:description" content="">

    <link rel="stylesheet" href="/assets/css/style.css">

    <meta name="generator" content="Ghost ?" />
<link rel="alternate" type="application/rss+xml" title="Mixu&#39;s blog" href="/rss/">
<link rel="canonical" href="http://localhost:5000//2011/08/13/nginx-websockets-ssl-and-socket-io-deployment.md" />	
</head>
<body class="post-template">
	
<main id="container" role="main">
	<header class="header" role="banner" style="background-image: url(/assets/img/header.jpg);">
		<h1 class="blog-title">
			<a href="http://localhost:5000">Mixu&#x27;s blog</a>
		</h1>
		<div class="blog-description">A blog</div>
	</header>
	<nav class="menu" role="navigation">
		<a href="#">Home</a>
		<span class="delimiter">&#8226;</span>
		<a href="#">About</a>
		<span class="delimiter">&#8226;</span>
		<a href="#">Contacts</a>
	</nav>
	<section class="post-full">
		<article itemscope itemtype="http://schema.org/BlogPosting" role="article" class="post">
			<header class="post-header">        		
    			<h2 itemprop="name headline" class="post-title">
    				<a href="/2011/08/13/nginx-websockets-ssl-and-socket-io-deployment.html" itemprop="url">Nginx, Websockets, SSL and Socket.IO deployment</a>
    			</h2>
    			<div class="post-meta">
        			<time datetime="2011-08-13" itemprop="datePublished">August 13, 2011</time>
        		</div>
        		<hr>
    		</header>
    		<section itemprop="articleBody" class="post-content">
    			<p>I&#39;ve spent some time recently figuring out the options for deploying Websockets with SSL and load balancing - and more specifically, Socket.IO - while allowing for dual stacks (e.g. Node.js and another dev platform). Since there seems to be very little concrete guidance on this topic, here are my notes - I&#39;d love to hear from you on your implementation  (leave a comment or write about and link back)...</p>
<p><strong>The goal here is to:</strong></p>
<p><ol>
    <li>Expose Socket.io and your main application from a single port -- avoiding cross-domain communication</li>
    <li>Support HTTPS for both connections -- enabling secure messaging</li>
    <li>Support the Websockets and Flashsockets transports from Socket.io -- for performance</li>
    <li>Perform load balancing for both the backends somewhere -- for performance</li>
</ol>
<span style="font-size: 20px; font-weight: bold;">Socket.io&#39;s various transports</span></p>
<p>Socket.io supports multiple different transports:</p>
<ul>
    <li>WebSockets -- which are essentially long lived HTTP 1.1 requests, which after a handshake upgrade to the Websockets protocol</li>
    <li>Flash sockets -- which are plain TCP sockets with optional SSL support (but Flash seems to use some older SSL encryption method)</li>
    <li>various kinds of polling -- which work over long lived HTTP 1.0 requests</li>
</ul>

<h2>Starting point: Nginx and Websockets</h2>

<p>Nginx is generally the first recommendation for Node.js deployments. It&#39;s a high-performance server and even includes support for proxying requests via the <a href="http://wiki.nginx.org/NginxHttpProxyModule">HttpProxyModule</a>.</p>
<p>However, -- and this should be made much obvious to people starting with Socket.io -- the problem is that while Nginx can talk HTTP/1.1 to the client (browser), it talks HTTP/1.0 to the server. Nginx&#39;s default HttpProxyModule does not support HTTP/1.1, which is needed for Websockets.</p>
<p>Websockets 76 requires support for HTTP/1.1 as the handshake mechanism is not compatible with HTTP/1.0. What this means is that if Nginx is used to reverse proxy a Websockets server (like Socket.io), then the WS connections will fail. So no Websockets for you if you&#39;re behind Nginx.</p>
<p>There is a workaround, but I don&#39;t see the benefit: use a TCP proxy (there is a <a href="https://github.com/yaoweibin/nginx_tcp_proxy_module">custom module for this by Weibin Yao</a>, <a href="http://www.letseehere.com/reverse-proxy-web-sockets">see here </a>). However, you cannot run another service on the same port (e.g. your main app and Socket.io on port 80) as the TCP proxy does not support routing based on the URL (e.g. /socket.io/ to Socket.io and the rest to the main app), only simple load balancing.</p>
<p>So the benefit gained from doing this is quite marginal: sure, you can use Nginx for load balancing, but you will still be working with alternative ports for your main app and Socket.io.</p>
<p><h2>Alternatives to Nginx</h2>
Since you can&#39;t use Nginx and support Websockets,  you&#39;ll need to deal with two separate problems:</p>
<p><ol>
    <li>How to terminate SSL connections and</li>
    <li>How to route HTTP traffic to the right backend based on the URL / load balance</li>
</ol>
If you want to run two services on the same port, then you will have to terminate SSL connections before doing anything else. There are several alternatives for SSL termination:</p>
<p><ul>
    <li><a href="http://www.stunnel.org/">Stunnel</a>. Supports multiple SSL certificates per process, does simple SSL termination to another port.</li>
    <li><a href="https://github.com/bumptech/stud">Stud</a>. Only supports one SSL certificate per invocation, does simple SSL termination to another port.</li>
    <li><a href="http://www.apsis.ch/pound/">Pound</a>. An SSL-termination-capable reverse proxy and load balancer.</li>
    <li>Node&#39;s https. Can be made to do anything, but you&#39;ll have to write it yourself.</li>
</ul>
If you choose Stunnel or Stud, then you need a load balancer as well if you plan on having more than one Node instance in the backend.</p>
<p>HAProxy is not <em>generally compatible</em> with Websockets, but Socket.IO <span style="text-decoration: underline;">contains code which works around this issue</span> and allows you to use HAProxy. This means that the alternatives are:</p>
<p><ul>
    <li>Stunnel for SSL termination + HAProxy for routing/load balancing</li>
    <li>Stud for SSL termination + HAProxy for routing/load balancing</li>
    <li>Pound (SSL and routing/load balancing)</li>
</ul>
I haven&#39;t looked into Pound more - mainly as I could not find info on it&#39;s TCP reverse proxying capabilities (see the section on Flash sockets below), but <a href="http://the-rig.refinery29.com/post/7263057532/pound-and-varnish">it seems to work for these guys</a>.</p>
<p><h2>Setting up Stunnel</h2>
The Stunnel part is quite simple:</p>
<pre class="hljs"><code><span class="hljs-setting">cert = <span class="hljs-value">/path/to/certfile.pem</span></span>
<span class="hljs-comment">; Service-level configuration</span>
<span class="hljs-title">[https]</span>
<span class="hljs-setting">accept  = <span class="hljs-value"><span class="hljs-number">443</span></span></span>
<span class="hljs-setting">connect = <span class="hljs-value"><span class="hljs-number">8443</span></span></span></code></pre><p>If you only have one Node instance, you can skip setting up HAProxy, since you don&#39;t need load balancing.</p>
<p><h2><strong>Setting up HAProxy</strong></h2>
<strong>Would you like Flash Sockets with that?</strong></p>
<p>Note that we need TCP mode in order to support Flash sockets, which do not speak HTTP.</p>
<p>Flash sockets are just plain and simple TCP sockets, which will start by sending the following payload: &#39;&lt;policy-file-request/&gt;&#39;. They expect to receive a Flash cross domain policy as a response.</p>
<p>Since Flash sockets don&#39;t use HTTP, we need a load balancer which is capable of detecting the protocol of the request, and of forwarding non-HTTP requests to Socket.io.</p>
<p>HAProxy can do that, as it has two different modes of operation:</p>
<p><ul>
    <li>HTTP mode - which allows you to specify the backend based on the URI</li>
    <li>TCP mode - which can be used to load balance non-HTTP transports.</li>
</ul>
<strong>Main frontend</strong></p>
<p>We accept connections on two ports: 80 (HTTP) and 8443 (Stunnel-terminated HTTPS connections).</p>
<p>By default, everything goes to the backend app at port 3000. Some HTTP paths are selectively routed to socket.io</p>
<p>TCP mode is needed so that Flash socket connections can be passed through, and all non HTTP connections are sent to the TCP mode socket.io backend.</p>
<pre class="hljs"><code><span class="hljs-comment"># Main frontend</span>
frontend app
  <span class="hljs-keyword">bind</span> <span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>:<span class="hljs-number">80</span>
  <span class="hljs-keyword">bind</span> <span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>:<span class="hljs-number">8443</span>
  <span class="hljs-comment"># Mode is TCP</span>
  mode tcp
  <span class="hljs-comment"># allow for many connections, with long timeout</span>
  maxconn <span class="hljs-number">200000</span>
  timeout client <span class="hljs-number">86400000</span>

  <span class="hljs-comment"># default to webapp backend</span>
  default_backend webapp

  <span class="hljs-comment"># two URLs need to go to the node pubsub backend</span>
  acl is_socket_io path_beg /node
  acl is_socket_io path_beg /<span class="hljs-keyword">socket</span>.io
     use_backend socket_io <span class="hljs-keyword">if</span> is_socket_io

   tcp-request inspect-delay <span class="hljs-number">500</span>ms
   tcp-request content <span class="hljs-keyword">accept</span> <span class="hljs-keyword">if</span> HTTP
   use_backend sio_tcp <span class="hljs-keyword">if</span> !HTTP</code></pre><p><strong>Port 843: Flash policy</strong></p>
<p>Flash policy should be made available on 843.</p>
<pre class="hljs"><code><span class="hljs-comment"># Flash policy frontend</span>
<span class="hljs-title">frontend</span> flashpolicy <span class="hljs-number">0.0.0.0:843</span>
   mode tcp
   default_backend sio_tcp</code></pre><p><strong>Default backend</strong></p>
<p>This is just for your main application.</p>
<pre class="hljs"><code>backend webapp
   mode http
   <span class="hljs-keyword">option</span> httplog
   <span class="hljs-keyword">option</span> httpclose
   <span class="hljs-built_in">server</span> nginx1s localhost:<span class="hljs-number">3000</span> check</code></pre><p><strong>Socket.io backend</strong></p>
<p>Here, we have a bunch of settings in order to allow Websockets connections through HAProxy.</p>
<pre class="hljs"><code>backend socket_io
  mode http
  option                  httplog
  # long timeout
  timeout server 86400000
  # <span class="hljs-operator"><span class="hljs-keyword">check</span> frequently <span class="hljs-keyword">to</span> allow restarting
  # the node backend
  timeout <span class="hljs-keyword">check</span> <span class="hljs-number">1</span>s
  # <span class="hljs-keyword">add</span> X-Forwarded-<span class="hljs-keyword">For</span>
   <span class="hljs-keyword">option</span> forwardfor
  # <span class="hljs-keyword">Do</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">use</span> httpclose (= client <span class="hljs-keyword">and</span> <span class="hljs-keyword">server</span>
  # connections <span class="hljs-keyword">get</span> closed), since it will <span class="hljs-keyword">close</span>
  # Websockets connections
  <span class="hljs-keyword">no</span>   <span class="hljs-keyword">option</span> httpclose
  # <span class="hljs-keyword">Use</span> <span class="hljs-string">&quot;option http-server-close&quot;</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">preserve</span>
  # client persistent connections while handling
  # every incoming request individually, dispatching
  # them one <span class="hljs-keyword">after</span> another <span class="hljs-keyword">to</span> servers, <span class="hljs-keyword">in</span> HTTP <span class="hljs-keyword">close</span> <span class="hljs-keyword">mode</span>
  <span class="hljs-keyword">option</span> http-<span class="hljs-keyword">server</span>-<span class="hljs-keyword">close</span>
  <span class="hljs-keyword">option</span> forceclose
  # just one node <span class="hljs-keyword">server</span> <span class="hljs-keyword">at</span> :<span class="hljs-number">8000</span>
  <span class="hljs-keyword">server</span> node1 localhost:<span class="hljs-number">8000</span> maxconn <span class="hljs-number">2000</span> <span class="hljs-keyword">check</span></span></code></pre><p><strong>Socket.io backend in TCP mode</strong></p>
<h2 id="comments">Comments</h2>
<p><strong><a href="#535" title="2011-08-18 23:52:20">Tom</a>:</strong> How are you handling HTTP requests then?</p>
<p><strong><a href="#536" title="2011-08-19 01:28:24">Mikito Takada</a>:</strong> As configured above, HAProxy listens at two ports:</p>
<p>80 (e.g. for direct HTTP requests)
8443 (e.g. for SSL-terminted HTTP requests)</p>
<p>And the default HAProxy backend is the main app.</p>
<p>HTTP comes in at port 80 to HAproxy.
HTTPS comes in at port 443 -&gt; Stunnel terminates SSL -&gt; 8443</p>
<p><strong><a href="#537" title="2011-08-30 15:26:23">Andrew</a>:</strong> Hi, we&#39;ve been integrating support for http/1.1 to backends for nginx lately. Would you like to test your setup with http/1.1 development code? Would be much appreciated.</p>
<p><strong><a href="#538" title="2011-08-31 10:48:43">mikong</a>:</strong> Hi Andrew,</p>
<p>We&#39;re working on NodeJS apps that needs Websockets, and thanks to your comment, we&#39;ll be taking a look at the development version of Nginx. We&#39;ll send you feedback for any problems.</p>
<p><strong><a href="#539" title="2011-09-02 20:47:27">Patrick</a>:</strong> Hi there,</p>
<p>I&#39;m trying to setup something similar. I have a rails app on port 3000, and a nodejs app on port 3001. The nodejs app doesnt only do sockets though... it also has a little http api using Express.</p>
<p>I wanted to have a different subdomain for each app, and use haproxy to serve the right thing but I can&#39;t seem to see how to do that... seems like when I use tcp mode I can&#39;t really do anything regarding the domain that was requested.</p>
<p><strong><a href="#540" title="2011-09-02 22:16:16">Mikito Takada</a>:</strong> Yeah, I found the tcp mode somewhat limited in Haproxy. You might want have a look at node-http-proxy...</p>
<p><strong><a href="#541" title="2011-09-03 16:49:03">Patrick</a>:</strong> I tried that first actually, for some reason I could not get node-http-proxy to work for Chrome PC and Internet Explorer. Or at least, socket.io seems to fall back to polling transports for some browsers when behind node-http-proxy. But maybe my configuration was wrong...</p>
<p><strong><a href="#542" title="2011-09-30 03:38:39">Joe Lindsay</a>:</strong> We need to solve this problem, how can I get the right bytes to test http/1.1 backends to nginx?</p>
<p><strong><a href="#543" title="2011-10-04 15:59:55">theTestTube</a>:</strong> Maybe the following directive can let you deal with &quot;[...] The nodejs app doesnt only do sockets&quot;</p>
<p>  acl websocket hdr(Upgrade)    -i WebSocket</p>
<p>I found this at <a href="http://stackoverflow.com/questions/2419346/can-nginx-be-used-as-a-reverse-proxy-for-a-backend-websocket-server">http://stackoverflow.com/questions/2419346/can-nginx-be-used-as-a-reverse-proxy-for-a-backend-websocket-server</a></p>
<p><strong><a href="#544" title="2011-11-23 12:07:32">Luke</a>:</strong> This configuration does not work for me. According to HAProxy docs you cannot use layer 7 filtering with TCP mode. On my setup this caused to use random backend.</p>
<p>I managed to fix this configuration in HTTP mode. The main was flash-policy-file serving - it is not served if socket.io client manage to get the policy from the same server on port 843.</p>
<p>If you provide policy file on that port then flash will not request policy file and use standard HTTP headers for communication.  This makes HAProxy happy.</p>
<p>My config is here:
<a href="http://pastebin.com/g8KQSWTW">http://pastebin.com/g8KQSWTW</a></p>
<p>Many thanks for your post - it was the best starter to make websockets, xhr-pooling and flashsockets to work with HAProxy.</p>
<p><strong><a href="#545" title="2011-12-08 20:10:30">Pau ramon</a>:</strong> I use substacks bouncy <a href="https://github.com/substack/bouncy">https://github.com/substack/bouncy</a></p>
<p><strong><a href="#546" title="2011-12-31 02:24:52">Mike Lewis</a>:</strong> With newer versions of nginx you can use 1.1 for reverse proxying.</p>
<p>This seems to work for reverse proxying websocket connections:</p>
<pre class="hljs"><code><span class="hljs-title">location</span> / {
    <span class="hljs-title">chunked_transfer_encoding</span> <span class="hljs-built_in">off</span>;
    <span class="hljs-title">proxy_http_version</span> <span class="hljs-number">1</span>.<span class="hljs-number">1</span>;
    <span class="hljs-title">proxy_pass</span>        <span class="hljs-url"><a href="http://localhost:9001">http://localhost:9001</a></span>;
    <span class="hljs-title">proxy_buffering</span>   <span class="hljs-built_in">off</span>;
    <span class="hljs-title">proxy_set_header</span>  X-Real-IP  <span class="hljs-variable">$remote_addr</span>;
    <span class="hljs-title">proxy_set_header</span>  Host <span class="hljs-variable">$host</span>:<span class="hljs-number">9001</span>;
    <span class="hljs-title">proxy_set_header</span>  Connection <span class="hljs-string">&quot;Upgrade&quot;</span>;
    <span class="hljs-title">proxy_set_header</span>  Upgrade websocket;
}</code></pre><p><strong><a href="#548" title="2012-01-11 22:47:36">Jimb Esser</a>:</strong> I did a bunch of experimenting and some digging, and it appears there is not currently any way to get nginx to work with websockets using a method like that.  WebSockets needs more than just forwarding a request, and the nginx developers say more work would need to be done to get it proxying websockets.  You can, however, use nginx with the tcp proxying module to blindly load-balance, and then put stunnel on each of your application servers, though that removes most of the benefit of nginx.</p>
<p><strong><a href="#551" title="2012-04-21 11:46:25">Ximonn</a>:</strong> Why not do it simple and use two servers. Then configure dns to point socket.mydomain.com to the websocket server and mydomain.com to the nginx server.
You use different IP&#39;s but the same domain name, sofar I havent seen any issue with that.</p>
<p><strong><a href="#552" title="2012-04-24 20:19:18">Edgar</a>:</strong> Trying to load balance several node.js servers but can&#39;t make it work.
When using more than one server, the browser seems to keep reconnecting.
Everything is great when using just one node.</p>
<p>The haproxy conf I&#39;m using is the following.
Am I missing anything?</p>
<p>backend socket_io
    balance roundrobin</p>
<pre class="hljs"><code>mode http
option                  httplog

# long timeout
timeout queue 5000
timeout server 86400000
timeout connect 86400000

# <span class="hljs-operator"><span class="hljs-keyword">check</span> frequently <span class="hljs-keyword">to</span> allow restarting
# the node backend
timeout <span class="hljs-keyword">check</span> <span class="hljs-number">1</span>s

# <span class="hljs-keyword">add</span> X-Forwarded-<span class="hljs-keyword">For</span>
<span class="hljs-keyword">option</span> forwardfor

# <span class="hljs-keyword">Do</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">use</span> httpclose (= client <span class="hljs-keyword">and</span> <span class="hljs-keyword">server</span>
# connections <span class="hljs-keyword">get</span> closed), since it will <span class="hljs-keyword">close</span>
# Websockets connections
<span class="hljs-keyword">no</span>   <span class="hljs-keyword">option</span> httpclose

# <span class="hljs-keyword">Use</span> <span class="hljs-string">&quot;option http-server-close&quot;</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">preserve</span>
# client persistent connections while handling
# every incoming request individually, dispatching
# them one <span class="hljs-keyword">after</span> another <span class="hljs-keyword">to</span> servers, <span class="hljs-keyword">in</span> HTTP <span class="hljs-keyword">close</span> <span class="hljs-keyword">mode</span>
<span class="hljs-keyword">option</span> http-<span class="hljs-keyword">server</span>-<span class="hljs-keyword">close</span>
<span class="hljs-keyword">option</span> forceclose


# balance
<span class="hljs-keyword">server</span> node1 <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">8001</span> weight <span class="hljs-number">1</span> maxconn <span class="hljs-number">2000</span> <span class="hljs-keyword">check</span>
<span class="hljs-keyword">server</span> node2 <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">8002</span> weight <span class="hljs-number">1</span> maxconn <span class="hljs-number">2000</span> <span class="hljs-keyword">check</span></span></code></pre><p><strong><a href="#553" title="2012-04-24 21:37:09">Mikito Takada</a>:</strong> Hi Edgar,</p>
<p>You can&#39;t round robin Socket.io - it&#39;s a protocol spec limitation.</p>
<p>I&#39;ve written a follow up to this post on my book, just skip to the section &quot;Sample deployments: scaling&quot; at <a href="http://book.mixu.net/ch13.html">http://book.mixu.net/ch13.html</a></p>
<p><strong><a href="#554" title="2012-04-24 22:28:55">Edgar</a>:</strong> Hi,</p>
<p>You saved my day.
Thanks.</p>
<p><strong><a href="#555" title="2012-05-28 10:35:46">James</a>:</strong> I believe that would run amok of SOP restrictions</p>
<p><strong><a href="#556" title="2012-06-26 11:16:16">Ram</a>:</strong> How about node-http-proxy  - <a href="https://github.com/nodejitsu/node-http-proxy">https://github.com/nodejitsu/node-http-proxy</a></p>
<p><strong><a href="#577" title="2012-08-15 20:30:00">coryvirok</a>:</strong> Great post! I setup the same deployment for <a href="https://ratchet.io/">https://ratchet.io/</a> earlier this year. We are, however running into some trouble with stunnel not setting the x-forwarded-for header. Looks like stunnel supports something like this via the transparent=source config option however our server&#39;s kernel doesn&#39;t have the necessary flags enabled.</p>
<p>Are you able to get the incoming client IP from your node.js or ruby servers?</p>
<p><strong><a href="#586" title="2012-10-25 16:24:18">Axel</a>:</strong> Another way to deploy Socket.IO is to use Kaazing&#39;s HTML5 Gateway. Kaazing will proxy the Socket.IO traffic and it takes care of the scaling, emulation, clustering, security and even provides an SSO integration. The Gateway is basically like a network router, except it&#39;s protocol aware. Kaazing does all the emulation if WS is not available in a particular browser so you don&#39;t have to worry about getting polling and Flash-Socket to work. In fact, the polling fall back from Socket.IO is really slow, and also seriously increases the battery consumption on mobile apps. And Flash Socket is notoriously insecure. Kaazing will emulate WS all the way back to an old IE6 browser as well, and doesn&#39;t have the firewall traversal issues that Socket.IO&#39;s alternate transport layers have.</p>
<p>All you have to do is to put Node.JS behind the Gateway and use only the WS transport. You just use the Kaazing client library below the Socket.IO client library and you make sure the client also uses the WS transport only. The Gateway will readily take care of all production needs from there on. Their Cloud solution is relatively cheap, you can just rent an EC2 instance, the cost is a tiny fraction on top of what EC2 charges, and it adds up to much less than some of the basic publish/subscribe service providers out there. And there is no lock in because the entire Kaazing stack is based on the WS standard, so you just program against the WS APIs.</p>
<p>Now a disclaimer: I work for Kaazing, but I am not posting this on behalf of Kaazing. I happen to be a major fan and enthousiast of Node.JS, and I would like to see more Node.JS adoption in large enterprises. Kaazing unfortunately doesn&#39;t currently market this solution at all. Using Kaazing to deploy Node.JS just makes Node.JS so much more attractive to enterprise shops because it overcomes any and all objections anyone would have against using Node.JS in an enterprise.</p>
<p><strong><a href="#600" title="2012-12-13 01:47:20">Asbestos</a>:</strong> Pound doesn&#39;t work.
Nginx should have websocket compatibility by Jan 2012 - <a href="http://trac.nginx.org/nginx/roadmap">http://trac.nginx.org/nginx/roadmap</a></p>
<p><strong><a href="#606" title="2012-12-27 16:10:50">suff</a>:</strong> HAProxy from version 1.5dev12 (currently 1.5dev16) supports SSL.</p>

    		</section>
    		<footer class="post-footer">
    			<div itemscope itemprop="author" itemtype="http://schema.org/Person" class="post-author">
	                	<img itemprop="image" src="http://www.gravatar.com/avatar/F0AF2953911805542C66FD43B2F8FC38?s=155" alt="Mixu" class="post-author-avatar">
					<div class="post-author-info">
		              	<span itemprop="name">Mixu</span>
		              	<p itemprop="description" class="post-author-bio">Node.js developer</p>
	              	</div>
    			</div>
    		</footer>
		</article>
		
		<section itemprop="comment" class="post-comments">
			<div id="disqus_thread"></div>
			<script type="text/javascript">            
				var disqus_shortname = 'example';
		
			    (function() {
			        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
			        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
			        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
			    })();
			</script>
			<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
			<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
		</section>	</section>

	<footer class="footer" role="contentinfo">
		<div class="social-links-line"></div>
		<section class="social-links">
	        <div class="social-links-inner">
	        	<a class="icon icon-feed" href="http://localhost:5000/rss/" target="_blank">
	        		<i class="fa fa-rss"></i>
	        	</a>
	        	
	        	<a class="icon icon-twitter" href="http://twitter.com/" target="_blank">				
	        		<i class="fa fa-twitter"></i>
	        	</a>
	        	
	        	<a class="icon icon-facebook" href="http://facebook.com/" target="_blank">
	        		<i class="fa fa-facebook"></i>
	        	</a>
	        	
	        	<a class="icon icon-google-plus" href="http://plus.google.com/" target="_blank">
	        		<i class="fa fa-google-plus"></i>
	        	</a>
	        	
	        	<a class="icon icon-dribbble" href="http://dribbble.com/" target="_blank">
	        		<i class="fa fa-dribbble"></i>
	        	</a>
	        	
	        	<a class="icon icon-flickr" href="http://flickr.com/" target="_blank">
	        		<i class="fa fa-flickr"></i>
	        	</a>
	        	
	        	<a class="icon icon-foursquare" href="http://foursquare.com/" target="_blank">
	        		<i class="fa fa-foursquare"></i>
	        	</a>
	        	
	        	<a class="icon icon-instagram" href="http://instagram.com/" target="_blank">
	        		<i class="fa fa-instagram"></i>
	        	</a>
	        	
	        	<a class="icon icon-github" href="http://github.com/" target="_blank">
	        		<i class="fa fa-github"></i>
	        	</a>
	        	
	        	<a class="icon icon-tumblr" href="http://tumblr.com/" target="_blank">
	        		<i class="fa fa-tumblr"></i>
	        	</a>
	        	
	        	<a class="icon icon-pinterest" href="http://pinterest.com/" target="_blank">
	        		<i class="fa fa-pinterest"></i>
	        	</a>
	        	
	        	<a class="icon icon-linkedin" href="http://linkedin.com/" target="_blank">
	        		<i class="fa fa-linkedin"></i>
	        	</a>
	        	
	        	<a class="icon icon-vk" href="http://vk.com/" target="_blank">
	        		<i class="fa fa-vk"></i>
	        	</a>        </div>               
	    </section>
	</footer></main>

	<script src="/assets/js/jquery.min.js"></script>
    <script type="text/javascript" src="/assets/js/main.min.js"></script>
</body>
</html>