<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

	<title>Javascript, node.js and for loops</title>	

	<meta name="description" content="">
	
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Javascript, node.js and for loops">
    <meta name="twitter:description" content="">
    <meta name="twitter:site" content="@username">
	<meta name="twitter:creator" content="@username">

    <meta property="og:type" content="article">
    <meta property="og:title" content="Javascript, node.js and for loops">
    <meta property="og:description" content="">

    <link rel="stylesheet" href="/assets/css/style.css">

    <meta name="generator" content="Ghost ?" />
<link rel="alternate" type="application/rss+xml" title="Mixu&#39;s blog" href="/rss/">
<link rel="canonical" href="http://localhost:5000//2011/02/03/javascript-node-js-and-for-loops.md" />	
</head>
<body class="post-template">
	
<main id="container" role="main">
	<header class="header" role="banner" style="background-image: url(/assets/img/header.jpg);">
		<h1 class="blog-title">
			<a href="http://localhost:5000">Mixu&#x27;s blog</a>
		</h1>
		<div class="blog-description">A blog</div>
	</header>
	<nav class="menu" role="navigation">
		<a href="#">Home</a>
		<span class="delimiter">&#8226;</span>
		<a href="#">About</a>
		<span class="delimiter">&#8226;</span>
		<a href="#">Contacts</a>
	</nav>
	<section class="post-full">
		<article itemscope itemtype="http://schema.org/BlogPosting" role="article" class="post">
			<header class="post-header">        		
    			<h2 itemprop="name headline" class="post-title">
    				<a href="/2011/02/03/javascript-node-js-and-for-loops.html" itemprop="url">Javascript, node.js and for loops</a>
    			</h2>
    			<div class="post-meta">
        			<time datetime="2011-02-03" itemprop="datePublished">February 03, 2011</time>
        		</div>
        		<hr>
    		</header>
    		<section itemprop="articleBody" class="post-content">
    			<p>What does this code print out? Assume that console.log logs to the console.</p>
<p><strong>Experiment #1: For loop</strong></p>
<pre class="hljs"><code><span class="hljs-transposed_variable">console.</span><span class="hljs-built_in">log</span>(<span class="hljs-string">&#39;For loop&#39;</span>);
<span class="hljs-keyword">for</span>(var <span class="hljs-built_in">i</span> = <span class="hljs-number">0</span>; <span class="hljs-built_in">i</span> &amp;lt; <span class="hljs-number">5</span>; <span class="hljs-built_in">i</span>++) <span class="hljs-cell">{
 console.log(i);
}</span></code></pre><p>0, 1, 2, 3, 4 - easy, right? What about this code?</p>
<p><strong>Experiment #2: setTimeout</strong></p>
<pre class="hljs"><code><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;setTimeout&#39;</span>);
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &amp;lt; <span class="hljs-number">5</span>; i++) {
  setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;st:&#39;</span>+i)}, <span class="hljs-number">0</span>);
}</code></pre><p>The result is 5, 5, 5, 5, 5.What about this?</p>
<p><strong>Experiment #3: Callback function</strong></p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrap</span><span class="hljs-params">(callback)</span> </span>{
  callback();
}

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;Simple wrap&#39;</span>);
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &amp;lt; <span class="hljs-number">5</span>; i++) {
  wrap(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{<span class="hljs-built_in">console</span>.log(i)});
}</code></pre><p>0, 1, 2, 3, 4 -- right? (Yup.) And this?</p>
<p><strong>Experiment #4: While loop emulating sleep</strong></p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sleep</span><span class="hljs-params">(callback)</span> </span>{
  <span class="hljs-keyword">var</span> now = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime();
  <span class="hljs-keyword">while</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime() &amp;lt; now + <span class="hljs-number">1000</span>) {
   <span class="hljs-comment">// do nothing</span>
  }
  callback();
}

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;Sleep&#39;</span>);
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &amp;lt; <span class="hljs-number">5</span>; i++) {
  sleep(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{<span class="hljs-built_in">console</span>.log(i)});
}</code></pre><p>0, 1, 2, 3, 4. And this?</p>
<p><strong>Experiment #5: Node.js process.nextTick</strong></p>
<pre class="hljs"><code><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;nextTick&#39;</span>);
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &amp;lt; <span class="hljs-number">5</span>; i++) {
 process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;nt:&#39;</span>+i)});
}</code></pre><p>Well... it&#39;s 5, 5, 5, 5, 5.</p>
<p><strong>Experiment #6: Delayed calls</strong></p>
<pre class="hljs"><code>var data = [];
for (var i = 0; i &amp;lt; 5; i++) {
  data[i] = function foo() {
<span class="hljs-code">    alert(i);</span>
  };
}
data<a href="span class=&quot;hljs-link_url&quot;&gt;&lt;/span"><span class="hljs-link_label">0</span></a>; data<a href="span class=&quot;hljs-link_url&quot;&gt;&lt;/span"><span class="hljs-link_label">1</span></a>; data<a href="span class=&quot;hljs-link_url&quot;&gt;&lt;/span"><span class="hljs-link_label">2</span></a>; data<a href="span class=&quot;hljs-link_url&quot;&gt;&lt;/span"><span class="hljs-link_label">3</span></a>; data<a href="span class=&quot;hljs-link_url&quot;&gt;&lt;/span"><span class="hljs-link_label">4</span></a>;</code></pre><p>Again, 5, 5, 5, 5, 5.</p>
<h2><strong>Ok, I&#39;m confused. Why does this happen?</strong></h2>

<p>Looking at experiments #1 to #6, you can see a pattern emerge: delayed calls, whether they are via setTimeout(), Node.js-specific process.nextTick() or a simple array of functions all print the unexpected result &quot;5&quot;.</p>
<p>Fundamentally, the only thing that matters is<strong> at what time the function code is executed</strong>. setTimeout() and process.nextTick() ensure that the function is only executed at some later stage. Similarly, assigning functions into an array explicitly like in Experiment #6 means that the code within the function is only executed after the loop has been completed.</p>
<p>There are three things you need to remember about Javascript:</p>
<p><ol>
    <li>Variable scope is based on the nesting of functions. In other words, the position of the function in the source always determines what variables can be accessed; nested functions can access their parent&#39;s variables, non-nested functions can only access the topmost, global variables.</li>
    <li>Functions can create new scopes; the default behavior is to access previous scope.</li>
    <li>Some functions have the side-effect of being event-driven and executed later, rather than immediately. You can emulate this yourself by storing but not executing functions, see Experiment #6.</li>
</ol>
What we would expect, based on experience in other languages, is that in the for loop, calling the function would result in a call-by-value (since we are passing a primitive - an integer) and that function calls would run using a copy of that value at the time when the part of the code was &quot;passed over&quot; (e.g. when the surrounding code was executed). That&#39;s not what happens:</p>
<p><strong>A</strong><strong> nested</strong><strong> function does not get a copy of the value of the variable -- it gets a live reference to the variable itself and can access it at a much later stage.</strong> So while the reference to <em>i</em> is valid in both experiment 2, 5, and 6 they refer to the value of i at the time of their execution - which is on the next event loop - which is after the loop has run - which is why they get the value 5.</p>
<p><strong>Functions <span style="text-decoration: underline;">can</span> create new scopes but they do not have to.</strong> The default behavior allows us to refer back to the previous scope (all the way up to the global scope); this is why code executing at a later stage can still access i. Because no variable <em>i </em>exists in the current scope, the <em>i </em>from the parent scope is used; because the parent has already executed, the value of <em>i</em> is 5.</p>
<p>Hence, we can fix the problem by explicitly establishing a new scope every time the loop is executed; then referring back to that new inner scope later.  The only way to do this is to use an (anonymous) function plus explicitly defining a variable in that scope. There are two ways to do this:</p>
<p>Option 1) We can allow the value of i to &quot;leak&quot; from the previous scope, but explicitly establish a new variable j in the new scope to hold that value for future execution of nested functions:</p>
<p><strong>Experiment #7: Closure with new scope establishing a new variable</strong></p>
<pre class="hljs"><code><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;new scope nexttick with value binding in new func scope&#39;</span>);
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &amp;lt; <span class="hljs-number">5</span>; i++) {
 (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">var</span> j = i;
  process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;nexttick-new-scope-new-bind:&#39;</span>+j)});
 })();
}</code></pre><p>Resulting in 0, 1, 2, 3, 4. Accessing j returns the value of i at the time when the closure was executed - and as you can see, we are immediately executing the function by appending ();</p>
<p>We need to have that wrapping function, because only functions establish new scope. In fact, we are establishing five new scopes when the loop is run, each iteration creating a scope with its own, separate variable j with a different value (0, 1, 2, 3, 4); each accessible from the inner closure at the time the code in it is run. Without the wrapping closure the reference to j in the innermost closure would end up having the same scope as i; it would then have the value of i at the time of the execution; which would be 5.</p>
<p>Options 2: Or we can pass the value to the new scope as a parameter:</p>
<p><strong>Experiment #8: Settimeout in closure with new scope</strong></p>
<pre class="hljs"><code><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;new scope&#39;</span>);
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &amp;lt; <span class="hljs-number">5</span>; i++) {
 (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(i)</span> </span>{
  setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;st2:&#39;</span>+i)}, <span class="hljs-number">0</span>);
 })(i);
}</code></pre><p>Resulting in 0, 1, 2, 3, 4.</p>
<p>Now you should remember one more rule to understand the second solution:</p>
<p><ul>
    <li>Functions can be passed as data; they are only evaluated when explicitly evaluated (e.g. by appending () or by using function.call or function.apply).</li>
</ul>
So when we have (function(param))(param), we are calling the function immediately and parameters always establish a new variable/identifier in the function scope; that allows us to use the i from the new scope  in our delayed function call - since it is bound to the parameter, not to the parent scope.</p>
<p>This also means that this does NOT work (process.nextTick is interchangeable with setTimeout):</p>
<p><strong>Experiment #9: Closure with new scope containing callback triggered on process.nextTick</strong></p>
<pre class="hljs"><code><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;new scope nexttick&#39;</span>);
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &amp;lt; <span class="hljs-number">5</span>; i++) {
 (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
  process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;nexttick-new-scope:&#39;</span>+i)});
 })();
}</code></pre><p>5, 5, 5, 5, 5 - since i still refers to the old scope. Compare that with experiment #7, where while the inner code is the same, we actually establish a new variable in the wrapping closure&#39;s scope, which is then referred to by the inner code.</p>
<p><strong>Conclusion</strong></p>
<p>I should note that this has nothing do to with synchronicity or asynchronicity; it is simply the way in which scope resolution works for Javascript when code execution is delayed in some manner while referring to variables defined in the parent scope of the nested code.</p>
<h2 id="comments">Comments</h2>
<p><strong><a href="#450" title="2011-02-11 23:33:19">Gabriel Farrell</a>:</strong> Great post, with a clear explanation I&#39;m sure I&#39;ll refer to whenever people (myself included) get tripped up by this feature of JS.</p>
<p>One question: is it really true to say &quot;this has nothing do to with synchronicity or asynchronicity&quot;? Could this happen without asynchronous execution?</p>
<p><strong><a href="#451" title="2011-02-12 00:12:28">Mikito Takada</a>:</strong> Good question. I think it is valid to say that it has nothing to do with asynchronicity as such because this is a feature of Javascript&#39;s <em>scope handling and evaluation strategy</em> - what Dimitry calls &quot;Call by sharing&quot; (e.g. scope can refer to variables which have been influenced by previous evaluations and primitives are not passed by copying but rather via &quot;sharing&quot;).</p>
<p>For instance, if variables were passed &quot;by copying&quot; (when a structure is passed by value to a function it is completely copied), then this problem would not exist even if callbacks could be stored for later execution since every function call in the for loop would get it&#39;s own value (the value of the variable at call time not at the time it would be run. So you could have a Javascript-like language that would avoid this problem - however, in most cases we want things to work exactly like Javascript does them; it&#39;s just the for loops where we would like the value of the variable to be copied at call time.</p>
<p>Having this kind of scope resolution/evaluation strategy makes implementing asynchronous operations easy... but I would say that it is not essential to writing asynchronous code, it just makes writing asynchronous code a lot easier.</p>
<p>So the technical root cause is the scope resolution/evaluation strategy. Asynchrony refers to the ability of events to occur independently of the main program flow; i.e. it is about interacting with event sources like file I/O, network I/O or user actions. Here, the fact that the code can be executed later is not the reason why the problem occurs since given alternative scope resolution/evaluation strategies this problem would not occur.</p>
<p>To answer your question: &quot;Could this happen without asynchronous execution?&quot; the answer is no, but if you ask &quot;Could asynchronous execution be possible without this happening?&quot; the answer is yes.</p>
<p>It&#39;s all a bit academic, but I think it&#39;s best to understand why the problem occurs rather than just be satisfied with saying that it is a side-effect of asynchronous execution...</p>
<p><strong><a href="#452" title="2011-06-01 05:32:51">Chris Jacob</a>:</strong> THANK YOU! I was going insane trying to figure out why I kept getting the last iteration value ... I went with Experiment #7.</p>
<p>I tried Experiment #8 but modified as: (function(j) { ... test here without setTimeout ... }(i); It didn&#39;t work - execution wasn&#39;t in &quot;order&quot;. Expect I need a delayed function call like setTimeout to wrap it as you said. (FYI: my output was contained inside a Facebook API call - so network delay may also be the cause of the sequencing issue).</p>
<p><strong><a href="#453" title="2011-06-01 05:50:56">Chris Jacob</a>:</strong> Hi Mikito,</p>
<p>I have referenced your article for this StackOverflow issue:</p>
<p>&quot;Saving FB.api call&#39;s response to an array with a for loop with Javascript.&quot;
<a href="http://stackoverflow.com/questions/5971124/saving-fb-api-calls-response-to-an-array-with-a-for-loop-with-javascript/6195695">http://stackoverflow.com/questions/5971124/saving-fb-api-calls-response-to-an-array-with-a-for-loop-with-javascript/6195695</a></p>
<p>My answer is here:
<a href="http://stackoverflow.com/questions/5971124/saving-fb-api-calls-response-to-an-array-with-a-for-loop-with-javascript/6195695#6195695">http://stackoverflow.com/questions/5971124/saving-fb-api-calls-response-to-an-array-with-a-for-loop-with-javascript/6195695#6195695</a></p>
<p>Could you please accept my answer if it&#39;s correct... or comment if I got it wrong. Cheers! ^_^</p>
<p><strong><a href="#454" title="2011-06-06 01:36:33">Josh</a>:</strong> Another strategy you might mention is from underscore -- <a href="http://documentcloud.github.com/underscore/#bind">http://documentcloud.github.com/underscore/#bind</a></p>
<p>for(var i =0;i&lt;5;i++){
   process.nextTick(_.bind(function(index){
       console.log(index);
   }, this, i));
}</p>
<p>This is used to both bind the &#39;this&#39; parameter, and to optionally pass additional parameters (technique called currying).</p>
<p><strong><a href="#455" title="2011-06-06 06:51:20">Mikito Takada</a>:</strong> Yeah, that works too, though you don&#39;t really need underscore.js to make this work. If you look at the code in underscore.js, it returns a new function which means that a new scope is established.</p>
<p> // Create a function bound to a given object (assigning <code>this</code>, and arguments,
  // optionally). Binding with arguments is also known as <code>curry</code>.
  // Delegates to <strong>ECMAScript 5</strong>&#39;s native <code>Function.bind</code> if available.
  // We check for <code>func.bind</code> first, to fail fast when <code>func</code> is undefined.
  _.bind = function(func, obj) {
    if (func.bind === nativeBind &amp;&amp; nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    var args = slice.call(arguments, 2);
    return function() {
      return func.apply(obj, args.concat(slice.call(arguments)));
    };
  };</p>
<p><strong><a href="#456" title="2011-06-07 08:12:14">Josh</a>:</strong> I agree, you don&#39;t need underscore here. To keep the code more vanilla, I&#39;d commonly use your &#39;Experiment #8&#39; approach. The benefit of _.bind or Function.bind is that you get the benefit of also controlling what &#39;this&#39; refers to, which is a common bummer in implementing the class pattern in js. Of course, these libraries are just returning a function that calls .apply(this) with some variant of argument slicing. Since I&#39;m usually depending on underscore, its all there in a pretty package :: shrug ::</p>
<p>Happy coding (and good article)!</p>
<p><strong><a href="#458" title="2012-02-17 22:32:18">John Quaresma</a>:</strong> Thanks for posting this.</p>
<p>It&#39;s an interesting way to frame the lexical closure problem, which is a very common javascript test given to potential job candidates.  I share Mikito&#39;s concern that the overall emphasis on execution order rather than scoping and closures may mislead some naive readers.  Specifically, the reason this &#39;problem&#39; exists is that all inner functions will refer to the address and not the value of the variables that exist in their containing scope / closure.   The only way to break this is to create a new closure, and by extension a new variable scope / address space.  You&#39;ve definitely addressed that here, but since it&#39;s not framed as being the main point of the post, it may be lost on some.</p>
<p><strong><a href="#459" title="2012-02-18 16:17:18">Andrea Giammarchi</a>:</strong> and suddenly, you discover this problem does not exists with timers:
for(var i = 0; i &lt; 5; ++i) {
  setTimeout(function(i){console.log(i)}, 1, i);
}
// 0, 1, 2, 3, 4</p>
<p>setTimeout, and setInterval, accepts everywhere but IE extra arguments that are passed to the function with the value bound at definition time.</p>
<p>It looks that who ever created nextTick in node, didn&#039;t know enough about JavaScript timers.</p>
<p>In specs even in W3C <a href="http://www.w3.org/TR/html5/timers.html">http://www.w3.org/TR/html5/timers.html</a></p>
<p><strong><a href="#460" title="2012-05-28 11:18:57">Ash Clark</a>:</strong> Thanks this was just what I needed!</p>
<p><strong><a href="#461" title="2012-05-28 11:19:51">Ash Clarke</a>:</strong> Thanks Mikito, this was just what I needed!</p>

    		</section>
    		<footer class="post-footer">
    			<div itemscope itemprop="author" itemtype="http://schema.org/Person" class="post-author">
	                	<img itemprop="image" src="http://www.gravatar.com/avatar/F0AF2953911805542C66FD43B2F8FC38?s=155" alt="Mixu" class="post-author-avatar">
					<div class="post-author-info">
		              	<span itemprop="name">Mixu</span>
		              	<p itemprop="description" class="post-author-bio">Node.js developer</p>
	              	</div>
    			</div>
    		</footer>
		</article>
		
		<section itemprop="comment" class="post-comments">
			<div id="disqus_thread"></div>
			<script type="text/javascript">            
				var disqus_shortname = 'example';
		
			    (function() {
			        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
			        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
			        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
			    })();
			</script>
			<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
			<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
		</section>	</section>

	<footer class="footer" role="contentinfo">
		<div class="social-links-line"></div>
		<section class="social-links">
	        <div class="social-links-inner">
	        	<a class="icon icon-feed" href="http://localhost:5000/rss/" target="_blank">
	        		<i class="fa fa-rss"></i>
	        	</a>
	        	
	        	<a class="icon icon-twitter" href="http://twitter.com/" target="_blank">				
	        		<i class="fa fa-twitter"></i>
	        	</a>
	        	
	        	<a class="icon icon-facebook" href="http://facebook.com/" target="_blank">
	        		<i class="fa fa-facebook"></i>
	        	</a>
	        	
	        	<a class="icon icon-google-plus" href="http://plus.google.com/" target="_blank">
	        		<i class="fa fa-google-plus"></i>
	        	</a>
	        	
	        	<a class="icon icon-dribbble" href="http://dribbble.com/" target="_blank">
	        		<i class="fa fa-dribbble"></i>
	        	</a>
	        	
	        	<a class="icon icon-flickr" href="http://flickr.com/" target="_blank">
	        		<i class="fa fa-flickr"></i>
	        	</a>
	        	
	        	<a class="icon icon-foursquare" href="http://foursquare.com/" target="_blank">
	        		<i class="fa fa-foursquare"></i>
	        	</a>
	        	
	        	<a class="icon icon-instagram" href="http://instagram.com/" target="_blank">
	        		<i class="fa fa-instagram"></i>
	        	</a>
	        	
	        	<a class="icon icon-github" href="http://github.com/" target="_blank">
	        		<i class="fa fa-github"></i>
	        	</a>
	        	
	        	<a class="icon icon-tumblr" href="http://tumblr.com/" target="_blank">
	        		<i class="fa fa-tumblr"></i>
	        	</a>
	        	
	        	<a class="icon icon-pinterest" href="http://pinterest.com/" target="_blank">
	        		<i class="fa fa-pinterest"></i>
	        	</a>
	        	
	        	<a class="icon icon-linkedin" href="http://linkedin.com/" target="_blank">
	        		<i class="fa fa-linkedin"></i>
	        	</a>
	        	
	        	<a class="icon icon-vk" href="http://vk.com/" target="_blank">
	        		<i class="fa fa-vk"></i>
	        	</a>        </div>               
	    </section>
	</footer></main>

	<script src="/assets/js/jquery.min.js"></script>
    <script type="text/javascript" src="/assets/js/main.min.js"></script>
</body>
</html>