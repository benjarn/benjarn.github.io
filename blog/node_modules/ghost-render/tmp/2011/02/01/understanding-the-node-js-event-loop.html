<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

	<title>Understanding the node.js event loop</title>	

	<meta name="description" content="">
	
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Understanding the node.js event loop">
    <meta name="twitter:description" content="">
    <meta name="twitter:site" content="@username">
	<meta name="twitter:creator" content="@username">

    <meta property="og:type" content="article">
    <meta property="og:title" content="Understanding the node.js event loop">
    <meta property="og:description" content="">

    <link rel="stylesheet" href="/assets/css/style.css">

    <meta name="generator" content="Ghost ?" />
<link rel="alternate" type="application/rss+xml" title="Mixu&#39;s blog" href="/rss/">
<link rel="canonical" href="http://localhost:5000//2011/02/01/understanding-the-node-js-event-loop.md" />	
</head>
<body class="post-template">
	
<main id="container" role="main">
	<header class="header" role="banner" style="background-image: url(/assets/img/header.jpg);">
		<h1 class="blog-title">
			<a href="http://localhost:5000">Mixu&#x27;s blog</a>
		</h1>
		<div class="blog-description">A blog</div>
	</header>
	<nav class="menu" role="navigation">
		<a href="#">Home</a>
		<span class="delimiter">&#8226;</span>
		<a href="#">About</a>
		<span class="delimiter">&#8226;</span>
		<a href="#">Contacts</a>
	</nav>
	<section class="post-full">
		<article itemscope itemtype="http://schema.org/BlogPosting" role="article" class="post">
			<header class="post-header">        		
    			<h2 itemprop="name headline" class="post-title">
    				<a href="/2011/02/01/understanding-the-node-js-event-loop.html" itemprop="url">Understanding the node.js event loop</a>
    			</h2>
    			<div class="post-meta">
        			<time datetime="2011-02-01" itemprop="datePublished">February 01, 2011</time>
        		</div>
        		<hr>
    		</header>
    		<section itemprop="articleBody" class="post-content">
    			<p>The first basic thesis of node.js is that I/O is expensive:</p>
<p>﻿<a href="http://blog.mixu.net/files/2011/01/io-cost.png"><img class="alignnone size-full wp-image-1661" title="io-cost" src="http://blog.mixu.net/files/2011/01/io-cost.png" alt="" width="509" height="362" /></a></p>
<p>So the largest waste with current programming technologies comes from waiting for I/O to complete.  There are several ways in which one can deal with the performance impact (from <a href="http://www.nightmare.com/medusa/async_sockets.html">Sam Rushing</a>):</p>
<ul>
    <li><strong>synchronous</strong>: you handle one request at a time, each in turn. <em>pros</em>: simple <em>cons</em>: any one request can hold up all the other requests</li>
    <li><strong>fork a new process</strong>: you start a new process to handle each request. <em>pros</em>: easy <em>cons</em>: does not scale well, hundreds of connections means hundreds of processes. fork() is the Unix programmer&#39;s hammer. Because it&#39;s available, every problem looks like a nail. It&#39;s usually overkill</li>
    <li><strong>threads</strong>: start a new thread to handle each request. <em>pros</em>: easy, and kinder to the kernel than using fork, since threads usually have much less overhead <em>cons</em>: your machine may not have threads, and threaded programming can get very complicated very fast, with worries about controlling access to shared resources.</li>
</ul>

<p>The second basis thesis is that thread-per-connection is memory-expensive:  [e.g. that graph everyone showns about Apache sucking up memory compared to Nginx]</p>
<p>Apache is multithreaded: it spawns a <a href="http://httpd.apache.org/docs/2.0/mod/worker.html">thread per request</a> (or <a href="http://httpd.apache.org/docs/2.0/mod/prefork.html">process</a>, it depends on the conf). You can see how that overhead eats up memory as the number of concurrent connections increases and more threads are needed to serve multiple simulataneous clients.  Nginx and Node.js are not multithreaded, because threads and processes carry a heavy memory cost. They are single-threaded, but event-based. This eliminates the overhead created by thousands of threads/processes by handling many connections in a single thread.</p>
<h2><strong>Node.js keeps a single thread for your code...</strong></h2>
It really is a single thread running: you can&#39;t do any parallel code execution; doing a &quot;sleep&quot; for example will block the server for one second:

<code>js
while(new Date().getTime() &amp;lt; now + 1000) {
   // do nothing
}</code>

So while that code is running, node.js will not respond to any other requests from clients, since it only has one thread for executing your code. Or if you would have some CPU -intensive code, say, for resizing images, that would still block all other requests.

<h2><strong>...however, everything runs in parallel <span style="text-decoration: underline;">except your code</span></strong></h2>

<p>There is no way of making code run in parallel within a single request. However, all I/O is evented and asynchronous, so the following won&#39;t block the server:  [codesyntax lang=&quot;javascript&quot;]</p>
<pre class="hljs"><code> c.query(
   <span class="hljs-string">&#39;SELECT SLEEP(20);&#39;</span>,
   <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err, results, fields)</span> <span class="hljs-comment">{
     if (err) {
       throw err;
     }</span>
     <span class="hljs-title">res</span>.<span class="hljs-title">writeHead</span><span class="hljs-params">(200, {<span class="hljs-string">&#39;Content-Type&#39;</span>: <span class="hljs-string">&#39;text/html&#39;</span>})</span>;</span>
     res.<span class="hljs-keyword">end</span>(<span class="hljs-string">&#39;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;Hello&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;lt;h1&amp;gt;Return from async DB query&amp;lt;/h1&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&#39;</span>);
     c.<span class="hljs-keyword">end</span>();
    }
);</code></pre><p>If you do that in one request, other requests can be processed just fine while the database is running it&#39;s sleep.</p>
<p><h2>Why is this good? When do we go from sync to async/parallel execution?</h2>
Having synchronous execution is good, because it simplifies writing code (compared to threads, where concurrency issues have a tendency to result in WTFs).</p>
<p>In node.js, you aren&#39;t supposed to worry about what happens in the backend: just use callbacks when you are doing I/O; and you are guaranteed that your code is never interrupted and that doing I/O will not block other requests without having to incur the costs of thread/process per request (e.g. memory overhead in Apache).</p>
<p>Having asynchronous I/O is good, because I/O is more expensive than most code and we should be doing something better than just waiting for I/O.</p>
<p><a href="http://blog.mixu.net/files/2011/01/bucket_3.gif"><img class="alignnone size-full wp-image-1663" title="bucket_3" src="http://blog.mixu.net/files/2011/01/bucket_3.gif" alt="" width="378" height="226" /></a></p>
<p>An event loop is &quot;an entity that handles and processes external events and converts them into callback invocations&quot;. So I/O calls are the points at which Node.js can switch from one request to another. At an I/O call, your code saves the callback and returns control to the node.js runtime environment. The callback will be called later when the data actually is available.</p>
<p>Of course, on the backend, there are <a href="http://stackoverflow.com/questions/3629784/how-is-node-js-inherently-faster-when-it-still-relies-on-threads-internally">threads and processes for DB access and process execution</a>. However, these are not explicitly exposed to your code, so you can&#39;t worry about them other than by knowing that I/O interactions e.g. with the database, or with other processes will be asynchronous from the perspective of each request since the results from those threads are returned via the event loop to your code. Compared to the Apache model, there are a lot less threads and thread overhead, since threads aren&#39;t needed for each connection; just when you absolutely positively must have something else running in parallel and even then the management is handled by Node.js.</p>
<p>Other than I/O calls, Node.js expects that all requests return quickly; e.g. <a href="http://stackoverflow.com/questions/3491811/node-js-and-cpu-intensive-requests">CPU-intensive work should be split off to another process</a> with which you can interact as with events, or by using an abstraction like <a href="http://blog.std.in/2010/07/08/nodejs-webworker-design/">WebWorkers</a>. This (obviously) means that you can&#39;t parallelize your code without another thread in the background with which you interact via events. Basically, all objects which emit events (e.g. are instances of EventEmitter) support asynchronous evented interaction and you can interact with blocking code in this manner e.g. using files, sockets or child processes all of which are EventEmitters in Node.js. <a href="http://developer.yahoo.com/blogs/ydn/posts/2010/07/multicore_http_server_with_nodejs/">Multicore can be done</a> using this approach; see also: node-http-proxy.</p>
<p><strong>Internal implementation</strong></p>
<p><a href="https://github.com/ry/node/tree/master/deps">Internally</a>, node.js relies on <a href="http://software.schmorp.de/pkg/libev.html">libev</a> to provide the event loop, which is supplemented by <a href="http://software.schmorp.de/pkg/libeio.html">libeio</a> which uses pooled threads to provide asynchronous I/O. To learn even more,  have a look at the <a href="http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod">libev documentation</a>.</p>
<p><h2>So how do we do async in Node.js?</h2>
Tim Caswell describes the patterns in his <a href="http://creationix.com/jsconf.pdf">excellent presentation</a>:</p>
<p><ul>
    <li>First-class functions. E.g. we pass around functions as data, shuffle them around and execute them when needed.</li>
    <li>Function composition. Also known as having anonymous functions or closures that are executed after something happens in the evented I/O.</li></p>
<h2 id="comments">Comments</h2>
<p><strong><a href="#462" title="2011-02-07 19:54:15">Quora</a>:</strong> <strong>What server do I need to handle 1000+ users simultaneously?...</strong></p>
<p>If you want to handle a lot of real-time users, then your best choice is to go with an event-based, or non-blocking driven server. Taking this route will keep slow, wasteful, and unresponsive operations from killing performance, requiring that you crea...</p>
<p><strong><a href="#466" title="2011-03-08 16:27:52">chrelad</a>:</strong> Thanks for writing up this nice intro to the node.js event loop.</p>
<p><strong><a href="#467" title="2011-04-28 03:02:18">Adrian</a>:</strong> Very good description of the event loop. I still have a ton more to learn but this got me on the right path.  Node is insane!</p>
<p><strong><a href="#471" title="2011-07-11 06:34:49">Matt Freeman</a>:</strong> [quote]
The queries will run in parallel provided that the I/O library supports this (e.g. via connection pooling).
[/quote]</p>
<p>What has db connection pooling got to do with parallel query execution???</p>
<p><strong><a href="#472" title="2011-07-11 06:49:38">Mikito Takada</a>:</strong> Well, it really depends on the case you&#39;re thinking about, but what I&#39;m trying to say is that the underlying limitations of the I/O library determine the manner in which stuff gets executed. If you only have a single  connection to the DB such as MySQL, then you&#39;d only be able to launch one query at a time.</p>
<p>E.g. &quot;The MySQL Client-Server Protocol has no build-in support for asynchronous query execution. The state transition is always SEND - RECEIVE. After sending a query you always have to fetch its result in the very next step.&quot; (<a href="http://blog.ulf-wendel.de/?p=170">http://blog.ulf-wendel.de/?p=170</a>)</p>
<p>You can probably find counterexamples to this, however - notably the Node core modules.</p>
<p><strong><a href="#473" title="2011-08-01 22:56:56">Willy Wiggler</a>:</strong> I don&#39;t get this at all - you claim that node.js is better because it doesn&#39;t spawn off a bunch of threads and/or processes to deal with synchronous processing, but then you claim that the node runtime spawns off threads &amp; processes for DB access, etc...</p>
<p>I&#39;m very skeptical that node.js would scale better than a more traditional thread-per-request model.  The reality is that the node runtime will have to have some number of threads running to do the async IO.  I fail to see how this is beneficial over having a thread pool to consume incoming requests.</p>
<p>I&#39;d love to see some benchmarks that compare node.js implementations against other stacks.</p>
<p><strong><a href="#474" title="2011-08-02 09:54:18">Mikito Takada</a>:</strong> Well, Node is not a silver bullet  - but the thread-per-request model is pretty heavy due to overhead from processes.</p>
<p>And while some parts of Node will still use threads, it&#39;s not one process for each request but rather based the actual work you need to do. Also, Node defaults to using asynchronous APIs where available (which is pretty much in all the core APIs now). See <a href="http://blog.zorinaq.com/?e=34">http://blog.zorinaq.com/?e=34</a></p>
<p>Take epoll, for example, which offers async filesystem I/O and is the secret sauce behind Nginx and libev on Linux.</p>
<p>Here is an illustration of the overhead with epoll (nginx) vs. non-epoll (Apache).</p>
<p><a href="http://blog.webfaction.com/a-little-holiday-present">http://blog.webfaction.com/a-little-holiday-present</a></p>
<p>Tons of other benchmarks via Google, take them all with a grain of salt!</p>
<p><strong><a href="#480" title="2011-10-22 19:12:34">Shawn Adrian</a>:</strong> Great intro to this, answered some of my questions. I&#39;d love to see some basic code examples added to illustrate your points though, would help a bunch! Thanks for writing.</p>
<p><strong><a href="#482" title="2011-12-21 07:33:41">Jared</a>:</strong> This was a great article, thanks for taking the time to illustrate the brilliance behind &quot;event loop&quot; based systems. The one thing I wish people would point out is there is still a way to use node.js to handle heavy computation. While programing for the client side we all realized that setTimeout could be used on heavy a loop statement to maintain responsiveness. e.g.</p>
<p>instead of:
for (var x = 0 ; x &lt; 40000000; x++){
   //do something crazy.
}</p>
<p>var later = function(x, callback){
    if (x&lt;40000000){
        //do something crazy.
        later(x+1, callback);
    } else {callback();}
};</p>
<p>later(0, function(){alert(&quot;done&quot;);});</p>
<p>So lets not be scared to do something computationally expensive. Lets just be smart with how we write it. On the client side we learned that, so why is it so hard to learn it for the server side.</p>
<p>I really enjoyed your article. Thanks</p>
<p><strong><a href="#484" title="2012-01-01 18:29:14">Battur</a>:</strong> In your example code you did not use setTimeout to maintain responsiveness. Recursively calling your later function many times does not bring anything good in terms of responsiveness. On top of that each invocation of later function will create a number of new objects related to new execution context, which will eat the memory quickly until it calls the passed in callback function and gets garbage collected.</p>
<p><strong><a href="#485" title="2012-01-01 22:09:54">Mikito Takada</a>:</strong> Agreed - you&#39;ll run out of stack space.</p>
<p>I&#39;d say that when the task is &quot;do something computationally intensive fast&quot; on the server side, the answer is <em>not</em> &quot;let&#39;s use a coding trick that makes the runtime slightly more responsive&quot; e.g. setTimeout or process.nextTick().</p>
<p>Node is fast for a dynamic language, but the event loop is not intended to make computationally intensive tasks responsive, it&#39;s meant to cut the resource waste related to waiting for I/O. If you saturate CPU, the solution is to find a more efficient algorithm, add caching and/or distribute the work as background tasks over several boxes.</p>
<p><strong><a href="#487" title="2012-01-17 17:14:29">Beo</a>:</strong> Thanks for this explanation, you made it very clear.</p>
<p><strong><a href="#488" title="2012-01-23 16:34:44">Punit Pandey</a>:</strong> Best explanation of Node.js benefits so far. Well done.</p>
<p><strong><a href="#489" title="2012-01-27 16:06:51">Jeff</a>:</strong> Where did you get your I/O metrics at the beginning of the article? I&#39;d like to reference them in an upcoming presentation if you don&#39;t mind. Thanks!</p>
<p><strong><a href="#490" title="2012-01-30 22:08:52">Aaron Hardy</a>:</strong> Very well-written.  Thank you.</p>
<p><strong><a href="#492" title="2012-02-14 04:07:36">Darío</a>:</strong> Thank you very much for your article, it&#39;s just brilliant!
By the way, loved your phrase &quot;When I read what I write I learn what I think&quot;!!
Cheers</p>
<p><strong><a href="#493" title="2012-02-14 07:51:48">C2D</a>:</strong> amazing post. Thank you.</p>
<p><strong><a href="#494" title="2012-02-17 21:23:35">Vijiay Rawat</a>:</strong> Very well written. Helped me a lot.</p>
<p><strong><a href="#496" title="2012-02-23 08:58:55">cantbecool</a>:</strong> Thanks for the introduction to Node&#39;s event loop.</p>
<p><strong><a href="#500" title="2012-03-06 22:23:09">D</a>:</strong> What confuses me about node.js is that I don&#39;t get what you really gain going from threads to async calls. In the end, you only have one CPU and only one process or thread can run code through it at a time. Of course you could have multi cores but threads can take advantage of that just as well as multiple processes. So what are you gaining?</p>
<p>And yes, multi-threaded issues like race conditions are a nightmare, but it&#39;s not valid to just say &quot;use multiple separate processes instead&quot;. Race conditions occur because your code <em>has</em> to have data shared across all threads. That&#39;s not something specific to threading, it&#39;s specific to the application you&#39;re writing. If you have shared data under multiple processes, you will have to implement inter-process communication, which is all a nightmare in its own right, and doesn&#39;t alleviate race conditions anyway.</p>
<p>And thirdly, if you only have one database running on a single box, how is this going to save you any time? Sure the web server will hand off the requests to the database server or file system very quickly but the database server has to serialize those requests to the disk to retrieve the data (ignoring caching that might occur at the database level). So you really, you are only as parallelizable as your database server or file system. Of course, that&#39;s the case with threads as well, but again, the point is that I don&#39;t see what asynch non-blocking IO gets you over threads.</p>
<p><strong><a href="#501" title="2012-03-06 23:59:30">Mikito Takada</a>:</strong> It&#39;s definitely not a silver bullet, but I find that with Node&#39;s evented async model, you get to write something that works quickly on a single process; since there is only one thread of execution, you gain simplicity. When it comes time to scale you skip thinking about scaling to multiple cores on a single machine and go directly to thinking about scaling to multiple machines. It&#39;s less efficient since instead of IPC you use sockets or an external service like Redis for a single machine, but I feel like the ability to scale by adding machines is more important. In my view, Node is about taking a simple idea (single-process event loops), and seeing how far one can go with it.</p>
<p><strong><a href="#502" title="2012-03-10 02:17:10">Mathias</a>:</strong> I&#39;m having  bit of trouble understanding this. Would node.js we useable for a blog were you have say 500 visitors a day? Or does the visitors have to wait in line to make requests and get a response.</p>
<p>Or another example: Would node.js work good for a proxy server doing api request? Can the server send a request, then continuing with 10 other requests, Right after the 5th request has started it gets a response for the first request, returns that to the user asking for it, then continuing with the 6th and so on?</p>
<p>Is this relevant at all?
Just trying to understand.</p>
<p><strong><a href="#503" title="2012-03-10 02:18:30">Mathias</a>:</strong> Got my email wrong, wheres the edit button?</p>
<p><strong><a href="#505" title="2012-03-21 08:08:16">Ed</a>:</strong> Some of this may be misleading to folks, although its a great article. There is an assumption in the blog that &quot;everything else runs in parallel.&quot; And that is simply not true. Libeio and libev, are themselve event loops which use epoll or some other AIO system to block until IO is ready.</p>
<p>I think the main issue is that folks get confused about IO. But IO  - to Node - is anything that involves a system call for IO: sockets, disk, etc. This is not database queries such as MySQL or anything else requiring user-mode processing.  IO is typically not CPU bound...  so this model works well.</p>
<p>You will see some threads if you run node in gdb, but just a couple. I am now running on node 0.7 and my understanding is there will be a worker thread pool eventually...</p>
<p>Mathias asks a question above... Yes, it could be used by 100k people a day, so long as you process stuff fast - otherwise you will need to go spawn your own thread using some native module. This is why <em>node</em> despite the hype, does not really scale well for CPU-bound work, but scales very well for IO-bound. Node does <em>not</em> take advantage of multi-core &amp; multi-cpu boxes well. But, there is nothing wrong with running a few node&#39;s at once on a box (given you figure out all the port redirect, etc)</p>
<p><a href="http://www.quora.com/How-does-IO-concurrency-work-in-node-js-despite-the-whole-app-running-in-a-single-thread">http://www.quora.com/How-does-IO-concurrency-work-in-node-js-despite-the-whole-app-running-in-a-single-thread</a></p>
<p><strong><a href="#506" title="2012-03-24 06:36:38">Dan</a>:</strong> Except modern webservers are not thread-per-request, many use threadpools. Usually, you have about 2x as many threads in your worker pool as cores. There is a acceptor thread that accepts incoming connections, and dispatches the request to threads in the worker pool. If there is a request that might take a bit of time to process, it doesn&#39;t prevent the other worker threads, or acceptor thread from doing their jobs. This architecture allows for utilizing all the available cores, without spawning tons of threads.</p>
<p>Seriously, Apache is slow. Tomcat as of 4-5 years ago, a JVM based server, was beating it on many benchmarks.</p>
<p><strong><a href="#507" title="2012-03-30 22:31:46">Michael Keisu</a>:</strong> Thank you so much, this cleared up so much of my confusion.</p>
<p><strong><a href="#512" title="2012-04-12 05:52:01">Jayesh Mori</a>:</strong> This is really helping. I am new to Node.JS and this helped understand what is going on behind the scene.</p>
<p><strong><a href="#513" title="2012-04-19 10:04:29">Ed</a>:</strong> Replying to another Ed...</p>
<p><strong><a href="#514" title="2012-04-19 10:52:19">Ed</a>:</strong> apologies...</p>
<p>Ed,</p>
<p>Call a spade for what it is.  node.js is anticipation of having more devs deploying code onto the cloud in a shorter fashion.</p>
<p>What would come about when everyone realized that libraries used to get access to these slow I/O services relied upon threads?  Would they spawn threads or processes to support it?</p>
<p>I&#39;m going to start hacking on a threaded version of node.js</p>
<p>cheers,</p>
<p>ed</p>
<p><strong><a href="#516" title="2012-05-15 10:54:07">Jorge</a>:</strong> For the &quot;everything runs in parallel except your code&quot; problem, there&#39;s the threads_a_gogo solution:</p>
<p><strong><a href="#517" title="2012-05-15 10:54:58">Jorge</a>:</strong> <a href="https://github.com/xk/node-threads-a-gogo">https://github.com/xk/node-threads-a-gogo</a></p>
<p><strong><a href="#526" title="2012-06-26 10:03:16">Alex</a>:</strong> What about INSERT DELAYED? That is non blocking</p>
<p><strong><a href="#612" title="2013-01-24 18:13:12">pligg.com</a>:</strong> <strong>Understanding the node.js event loop...</strong></p>
<p>So the largest waste with current programming technologies comes from waiting for I/O to complete. There are several ways in which one can deal with the performance impact......</p>

    		</section>
    		<footer class="post-footer">
    			<div itemscope itemprop="author" itemtype="http://schema.org/Person" class="post-author">
	                	<img itemprop="image" src="http://www.gravatar.com/avatar/F0AF2953911805542C66FD43B2F8FC38?s=155" alt="Mixu" class="post-author-avatar">
					<div class="post-author-info">
		              	<span itemprop="name">Mixu</span>
		              	<p itemprop="description" class="post-author-bio">Node.js developer</p>
	              	</div>
    			</div>
    		</footer>
		</article>
		
		<section itemprop="comment" class="post-comments">
			<div id="disqus_thread"></div>
			<script type="text/javascript">            
				var disqus_shortname = 'example';
		
			    (function() {
			        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
			        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
			        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
			    })();
			</script>
			<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
			<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
		</section>	</section>

	<footer class="footer" role="contentinfo">
		<div class="social-links-line"></div>
		<section class="social-links">
	        <div class="social-links-inner">
	        	<a class="icon icon-feed" href="http://localhost:5000/rss/" target="_blank">
	        		<i class="fa fa-rss"></i>
	        	</a>
	        	
	        	<a class="icon icon-twitter" href="http://twitter.com/" target="_blank">				
	        		<i class="fa fa-twitter"></i>
	        	</a>
	        	
	        	<a class="icon icon-facebook" href="http://facebook.com/" target="_blank">
	        		<i class="fa fa-facebook"></i>
	        	</a>
	        	
	        	<a class="icon icon-google-plus" href="http://plus.google.com/" target="_blank">
	        		<i class="fa fa-google-plus"></i>
	        	</a>
	        	
	        	<a class="icon icon-dribbble" href="http://dribbble.com/" target="_blank">
	        		<i class="fa fa-dribbble"></i>
	        	</a>
	        	
	        	<a class="icon icon-flickr" href="http://flickr.com/" target="_blank">
	        		<i class="fa fa-flickr"></i>
	        	</a>
	        	
	        	<a class="icon icon-foursquare" href="http://foursquare.com/" target="_blank">
	        		<i class="fa fa-foursquare"></i>
	        	</a>
	        	
	        	<a class="icon icon-instagram" href="http://instagram.com/" target="_blank">
	        		<i class="fa fa-instagram"></i>
	        	</a>
	        	
	        	<a class="icon icon-github" href="http://github.com/" target="_blank">
	        		<i class="fa fa-github"></i>
	        	</a>
	        	
	        	<a class="icon icon-tumblr" href="http://tumblr.com/" target="_blank">
	        		<i class="fa fa-tumblr"></i>
	        	</a>
	        	
	        	<a class="icon icon-pinterest" href="http://pinterest.com/" target="_blank">
	        		<i class="fa fa-pinterest"></i>
	        	</a>
	        	
	        	<a class="icon icon-linkedin" href="http://linkedin.com/" target="_blank">
	        		<i class="fa fa-linkedin"></i>
	        	</a>
	        	
	        	<a class="icon icon-vk" href="http://vk.com/" target="_blank">
	        		<i class="fa fa-vk"></i>
	        	</a>        </div>               
	    </section>
	</footer></main>

	<script src="/assets/js/jquery.min.js"></script>
    <script type="text/javascript" src="/assets/js/main.min.js"></script>
</body>
</html>